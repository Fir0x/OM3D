#version 450

// compute shader of a tonemap

layout(local_size_x = 16, local_size_y = 16) in;

layout(std430, binding = 0) writeonly buffer Tiles {
    bool tile_light_infos[];
};

struct Light {
    vec3 center;
    float radius;
};

layout(std430, binding = 1) readonly buffer Lights {
    Light lights[];
};

uniform int light_count;
uniform mat4 inv_view_proj;
uniform vec3 camera_position;

struct Frustum {
    vec3 left_plane_normal;
    vec3 right_plane_normal;
    vec3 bottom_plane_normal;
    vec3 top_plane_normal;
    vec3 near_plane_normal;
};

bool isInBound(vec3 light_dir, vec3 normal, float radius) {
    float dist = dot(light_dir, normal);
    return dist > -radius;
}

Frustum buildFrustum() {
    Frustum frustum;
    {
        // Left plane
        float shift = (2.0 * gl_LocalInvocationID.x) / (gl_WorkGroupSize.x + 1);
        vec4 clip_plane = vec4(1.0, 0.0, 0.0, -1.0 + shift);
        vec4 world_plane = inv_view_proj * clip_plane;
        frustum.left_plane_normal = normalize(world_plane.xyz);
    }
    {
        // Right plane
        float shift = (2.0 * (gl_WorkGroupSize.x - gl_LocalInvocationID.x)) / (gl_WorkGroupSize.x + 1);
        vec4 clip_plane = vec4(-1.0, 0.0, 0.0, -1.0 + shift);
        vec4 world_plane = inv_view_proj * clip_plane;
        frustum.right_plane_normal = normalize(world_plane.xyz);
    }
    {
        // Bottom plane
        float shift = (2.0 * gl_LocalInvocationID.y) / (gl_WorkGroupSize.y + 1);
        vec4 clip_plane = vec4(0.0, 1.0, 0.0, -1.0 + shift);
        vec4 world_plane = inv_view_proj * clip_plane;
        frustum.bottom_plane_normal = normalize(world_plane.xyz);
    }
    {        
        // Top plane
        float shift = (2.0 * (gl_WorkGroupSize.y - gl_LocalInvocationID.y)) / (gl_WorkGroupSize.y + 1);
        vec4 clip_plane = vec4(0.0, -1.0, 0.0, -1.0 + shift);
        vec4 world_plane = inv_view_proj * clip_plane;
        frustum.top_plane_normal = normalize(world_plane.xyz);
    }
    {
        // Near plane
        vec4 clip_plane = vec4(0.0, 0.0, 1.0, -1.0);
        vec4 world_plane = inv_view_proj * clip_plane;
        frustum.near_plane_normal = normalize(world_plane.xyz);
    }

    return frustum;
}

void main() {
    Frustum frustum = buildFrustum();
    for (int i = 0; i < light_count; i++) {
        Light light = lights[i];

        vec3 light_dir = light.center - camera_position;

        bool in_bound = isInBound(light_dir, frustum.top_plane_normal, light.radius);
        in_bound &= isInBound(light_dir, frustum.bottom_plane_normal, light.radius);
        in_bound &= isInBound(light_dir, frustum.right_plane_normal, light.radius);
        in_bound &= isInBound(light_dir, frustum.left_plane_normal, light.radius);
        in_bound &= isInBound(light_dir, frustum.near_plane_normal, light.radius);

        uint buffer_index = (gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x) * light_count + i;
        tile_light_infos[buffer_index] = in_bound;
    }
}